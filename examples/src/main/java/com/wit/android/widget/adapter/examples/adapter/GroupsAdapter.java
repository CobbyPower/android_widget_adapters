/*
 * =================================================================================
 * Copyright (C) 2013 Martin Albedinsky [Wolf-ITechnologies]
 * =================================================================================
 * Licensed under the Apache License, Version 2.0 or later (further "License" only);
 * ---------------------------------------------------------------------------------
 * You may use this file only in compliance with the License. More details and copy
 * of this License you may obtain at
 * 
 * 		http://www.apache.org/licenses/LICENSE-2.0
 * 
 * You can redistribute, modify or publish any part of the code written in this
 * file but as it is described in the License, the software distributed under the 
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES or CONDITIONS OF
 * ANY KIND.
 * 
 * See the License for the specific language governing permissions and limitations
 * under the License.
 * =================================================================================
 */
package com.wit.android.widget.adapter.examples.adapter;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import com.wit.android.widget.adapter.BaseMultiAdapter;
import com.wit.android.widget.adapter.examples.R;
import com.wit.android.widget.adapter.examples.adapter.module.GroupsModule;
import com.wit.android.widget.adapter.examples.model.Connection;
import com.wit.android.widget.adapter.examples.model.Group;

import java.util.ArrayList;
import java.util.List;

/**
 * <p>
 * Description.
 * </p>
 *
 * @author Martin Albedinsky
 */
public class GroupsAdapter extends BaseMultiAdapter<GroupsAdapter> {

	/**
	 * Log TAG.
	 */
	// private static final String TAG = GroupsAdapter.class.getSimpleName();

	/**
	 * Two types of views (item, header).
	 */
	protected static final int VIEW_TYPE_COUNT = 2;
	protected static final int VIEW_TYPE_HEADER = 0x00;
	protected static final int VIEW_TYPE_ITEM = 0x01;

	protected final List<Connection> CONNECTIONS = new ArrayList<Connection>();

	protected final GroupsModule GROUPS = new GroupsModule();

	/**
	 *
	 * @param context
	 */
	public GroupsAdapter(Context context) {
		super(context);

		// Adding module, attaches this adapter to it and also saving/restoring state can be handled
		// when invoking onSaveInstanceState() onRestoreInstanceState() on this adapter form its context.
		assignModule(GROUPS, 0);
		// Set attribute which holds the custom style for the header view.
		// Note, that this attribute must be placed in the main application theme.
		GROUPS.setHeaderStyleAttr(R.attr.adapterViewHeaderStyle);

		// Generate headers.
		this.updateHeaders();
	}

	/**
	 *
	 * @param connections
	 */
	public void loadConnections(List<Connection> connections) {
		CONNECTIONS.clear();
		CONNECTIONS.addAll(connections);
		this.updateHeaders();
	}

	/**
	 *
	 * @param position
	 * @return
	 */
	public boolean isItemAt(int position) {
		return !GROUPS.isHeaderAt(position);
	}

	/**
	 */
	@Override
	public int getCount() {
		// Total count of the adapter is count of its data set + headers generated by module.
		return CONNECTIONS.size() + GROUPS.getHeadersCount();
	}

	/**
	 */
	@Override
	public Connection getItem(int position) {
		// We will handle only obtaining of the items from data set.
		// If you would like handle also obtaining the header item
		// you can do this like so: GROUPS.getHeader(position)
		/**
		 * It is very important to ask headers module to correct
		 * current position. The correction is done way, that position will
		 * be decreased by count of the headers before that position.
		 */
		final int corrPos = GROUPS.correctPosition(position);
		return (corrPos < CONNECTIONS.size()) ? CONNECTIONS.get(corrPos) : new Connection("", Group.OTHERS);
	}

	/**
	 */
	@Override
	public int getItemViewType(int position) {
		// Headers module knows the positions of generated headers so we can resolve
		// header vs. item view type.
		return GROUPS.isHeaderAt(position) ? VIEW_TYPE_HEADER : VIEW_TYPE_ITEM;
	}

	/**
	 */
	@Override
	public int getViewTypeCount() {
		return VIEW_TYPE_COUNT;
	}

	/**
	 */
	@Override
	public View onCreateItemView(int position, LayoutInflater inflater, ViewGroup root) {
		View view = null;
		switch (currentItemViewType()) {
			case VIEW_TYPE_ITEM:
				view = inflate(R.layout.listitem_simple);
				break;
			case VIEW_TYPE_HEADER:
				view = GROUPS.createHeaderView(position, inflater, root);
				break;
		}
		return view;
	}

	/**
	 */
	@Override
	public void onBindItemView(int position, Object viewHolder) {
		switch (currentItemViewType()) {
			case VIEW_TYPE_ITEM:
				((ViewHolder) viewHolder).setText(
						(getItem(position)).getName()
				);
				break;
			case VIEW_TYPE_HEADER:
				GROUPS.bindHeaderView(position, viewHolder);
				break;
		}
	}

	/**
	 */
	@Override
	public Object onCreateItemViewHolder(int position, View itemView) {
		switch (currentItemViewType()) {
			case VIEW_TYPE_ITEM:
				return new ViewHolder(itemView);
			case VIEW_TYPE_HEADER:
				return GROUPS.createHeaderViewHolder(position, itemView);
		}
		return null;
	}

	/**
	 * Generates all headers for the current data set.
	 * This should be called whenever data set was changed.
	 */
	protected void updateHeaders() {
		// Module sorts items and also fires data set changed on the attached(this) adapter.
		GROUPS.processConnectionGroups(CONNECTIONS);
	}

	/**
	 *
	 */
	private class ViewHolder {

		/**
		 *
		 */
		TextView mTextView;

		/**
		 *
		 * @param itemView
		 */
		ViewHolder(View itemView) {
			this.mTextView = (TextView) itemView;
		}

		/**
		 *
		 * @param text
		 */
		void setText(String text) {
			mTextView.setText(text);
		}
	}
}
